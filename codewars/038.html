<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Ludicrous Coloured Triangles (2 kyu)</title>
<style>
.hll { background-color: #333333 }
.c { color: #008800; font-style: italic; background-color: #0f140f } /* Comment */
.err { color: #ffffff } /* Error */
.esc { color: #ffffff } /* Escape */
.g { color: #ffffff } /* Generic */
.k { color: #fb660a; font-weight: bold } /* Keyword */
.l { color: #ffffff } /* Literal */
.n { color: #ffffff } /* Name */
.o { color: #ffffff } /* Operator */
.x { color: #ffffff } /* Other */
.p { color: #ffffff } /* Punctuation */
.ch { color: #008800; font-style: italic; background-color: #0f140f } /* Comment.Hashbang */
.cm { color: #008800; font-style: italic; background-color: #0f140f } /* Comment.Multiline */
.cp { color: #ff0007; font-weight: bold; font-style: italic; background-color: #0f140f } /* Comment.Preproc */
.cpf { color: #008800; font-style: italic; background-color: #0f140f } /* Comment.PreprocFile */
.c1 { color: #008800; font-style: italic; background-color: #0f140f } /* Comment.Single */
.cs { color: #008800; font-style: italic; background-color: #0f140f } /* Comment.Special */
.gd { color: #ffffff } /* Generic.Deleted */
.ge { color: #ffffff } /* Generic.Emph */
.gr { color: #ffffff } /* Generic.Error */
.gh { color: #ffffff; font-weight: bold } /* Generic.Heading */
.gi { color: #ffffff } /* Generic.Inserted */
.go { color: #444444; background-color: #222222 } /* Generic.Output */
.gp { color: #ffffff } /* Generic.Prompt */
.gs { color: #ffffff } /* Generic.Strong */
.gu { color: #ffffff; font-weight: bold } /* Generic.Subheading */
.gt { color: #ffffff } /* Generic.Traceback */
.kc { color: #fb660a; font-weight: bold } /* Keyword.Constant */
.kd { color: #fb660a; font-weight: bold } /* Keyword.Declaration */
.kn { color: #fb660a; font-weight: bold } /* Keyword.Namespace */
.kp { color: #fb660a } /* Keyword.Pseudo */
.kr { color: #fb660a; font-weight: bold } /* Keyword.Reserved */
.kt { color: #cdcaa9; font-weight: bold } /* Keyword.Type */
.ld { color: #ffffff } /* Literal.Date */
.m { color: #0086f7; font-weight: bold } /* Literal.Number */
.s { color: #0086d2 } /* Literal.String */
.na { color: #ff0086; font-weight: bold } /* Name.Attribute */
.nb { color: #ffffff } /* Name.Builtin */
.nc { color: #ffffff } /* Name.Class */
.no { color: #0086d2 } /* Name.Constant */
.nd { color: #ffffff } /* Name.Decorator */
.ni { color: #ffffff } /* Name.Entity */
.ne { color: #ffffff } /* Name.Exception */
.nf { color: #ff0086; font-weight: bold } /* Name.Function */
.nl { color: #ffffff } /* Name.Label */
.nn { color: #ffffff } /* Name.Namespace */
.nx { color: #ffffff } /* Name.Other */
.py { color: #ffffff } /* Name.Property */
.nt { color: #fb660a; font-weight: bold } /* Name.Tag */
.nv { color: #fb660a } /* Name.Variable */
.ow { color: #ffffff } /* Operator.Word */
.w { color: #888888 } /* Text.Whitespace */
.mb { color: #0086f7; font-weight: bold } /* Literal.Number.Bin */
.mf { color: #0086f7; font-weight: bold } /* Literal.Number.Float */
.mh { color: #0086f7; font-weight: bold } /* Literal.Number.Hex */
.mi { color: #0086f7; font-weight: bold } /* Literal.Number.Integer */
.mo { color: #0086f7; font-weight: bold } /* Literal.Number.Oct */
.sa { color: #0086d2 } /* Literal.String.Affix */
.sb { color: #0086d2 } /* Literal.String.Backtick */
.sc { color: #0086d2 } /* Literal.String.Char */
.dl { color: #0086d2 } /* Literal.String.Delimiter */
.sd { color: #0086d2 } /* Literal.String.Doc */
.s2 { color: #0086d2 } /* Literal.String.Double */
.se { color: #0086d2 } /* Literal.String.Escape */
.sh { color: #0086d2 } /* Literal.String.Heredoc */
.si { color: #0086d2 } /* Literal.String.Interpol */
.sx { color: #0086d2 } /* Literal.String.Other */
.sr { color: #0086d2 } /* Literal.String.Regex */
.s1 { color: #0086d2 } /* Literal.String.Single */
.ss { color: #0086d2 } /* Literal.String.Symbol */
.bp { color: #ffffff } /* Name.Builtin.Pseudo */
.fm { color: #ff0086; font-weight: bold } /* Name.Function.Magic */
.vc { color: #fb660a } /* Name.Variable.Class */
.vg { color: #fb660a } /* Name.Variable.Global */
.vi { color: #fb660a } /* Name.Variable.Instance */
.vm { color: #fb660a } /* Name.Variable.Magic */
.il { color: #0086f7; font-weight: bold } /* Literal.Number.Integer.Long */
</style>
</head>
<body>
<h1>Ludicrous Coloured Triangles (2 kyu)</h1>
<h4 id="introduction">Introduction</h4>
<p>This kata is yet another version of Avanta's <a href="/kata/coloured-triangles" target="_blank">Coloured Triangles</a>, once again focused on performance.</p>
<p>It takes Bubbler's <a href="/kata/insane-coloured-triangles" target="_blank">"Insane" version</a> a step further, hence the name "Ludicrous".</p>
<p>I highly recommend having a close look at these other versions first, and solving them if you haven't already: they are super nice kata, and the test cases are significantly less challenging than what you'll find here.</p>
<h4 id="problem-description">Problem Description</h4>
<blockquote>
<p>This section has been borrowed from Avanta's kata.</p>
</blockquote>
<p>A coloured triangle is created from a row of colours, each of which is red, green or blue. Successive rows, each containing one fewer colour than the last, are generated by considering the two touching colours in the previous row. If these colours are identical, the same colour is used in the new row. If they are different, the missing colour is used in the new row. This is continued until the final row, with only a single colour, is generated.</p>
<p>For example, different possibilities are:</p>
<pre><code>Colour here:            G G        B G        R G        B R
Becomes colour here:     G          R          B          G
</code></pre>
<p>With a bigger example:</p>
<pre><code>R R G B R G B B
 R B R G B R B
  G G B R G G
   G R G B G
    B B R R
     B G R
      R B
       G
</code></pre>
<p>You will be given the first row of the triangle as a string and its your job to return the final colour which would appear in the bottom row as a string. In the case of the example above, you would the given <code>'RRGBRGBB'</code> you should return <code>'G'</code>.</p>
<ul>
<li>The input string will only contain the uppercase letters <code>'B'</code>, <code>'G'</code> or <code>'R'</code> and there will be at least one letter so you do not have to test for invalid input.</li>
<li>If you are only given one colour as the input, return that colour.</li>
</ul>
<p><em>Adapted from the 2017 British Informatics Olympiad</em></p>
<h4 id="challenge">Challenge</h4>
<p>The specificity of this kata resides in the very large size of the input strings that your function will have to crunch and digest.</p>
<p>As a reference, the test cases in Bubbler's <em>Insane</em> version go up to 100 000 characters. In this one, the limit is set to 1 000 000 000 characters. (That's 10 000 times more.)</p>
<p>With such large numbers, the challenge here will clearly not be about optimizing code execution, but about reducing algorithmic complexity.</p>
<p>Please note that the test cases are randomly generated, so the actual time it takes to complete the tests can vary from one attempt to the next. A good solution, though, should be able to beat the timeout 99% of the time.</p>

<h4>Starting Code</h4>
<pre><code>def triangle(row):
    pass</code></pre>

<h2>My Solution</h2>
<div style="background-color: black;">
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>


<span class="k">def</span> <span class="nf">triangle</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="c1"># Explanation of approach:</span>
    <span class="c1"># We associate each of the 3 colours/characters with a unique code: 0, 1, or 2.</span>
    <span class="c1"># With this encoding and the rules given, </span>
    <span class="c1"># we see that a pair of neighbours in one row will give rise in the next row</span>
    <span class="c1"># to a colour whose code is the negated sum of the two neighbours&#39; codes, reduced modulo 3.</span>
    <span class="c1"># Applying this repeatedly starting with a row of length m + 1,</span>
    <span class="c1"># we find that the code of the colour at the bottom tip of the triangle</span>
    <span class="c1"># is just the dot product of the mth row (zero-indexing, always) of Pascal&#39;s triangle</span>
    <span class="c1"># with the codes of the initial row of colours, </span>
    <span class="c1"># the result negated if m is odd, and reduced modulo 3.</span>
    <span class="c1"># Working modulo 3, Lucas&#39;s Theorem says that (m choose n), </span>
    <span class="c1"># the nth value/coefficient in the mth row of Pascal&#39;s triangle,</span>
    <span class="c1"># is congruent to the product of all (m_i choose n_i),</span>
    <span class="c1"># where m_i and n_i are the ith base-3 digits of m and n, respectively,</span>
    <span class="c1"># and (m_i choose n_i) is taken to be zero if m_i &lt; n_i.</span>
    <span class="c1"># Therefore nonzero coefficients appear precisely </span>
    <span class="c1"># when each base-3 digit of n is no greater than the corresponding base-3 digit of m.</span>
    <span class="c1"># Now, for such a coefficient, the factor (m_i choose n_i) is 2 if m_i == 2 and n_i == 1.  </span>
    <span class="c1"># Otherwise, the factor is 1.</span>
    <span class="c1"># Therefore, for such a coefficient, if k denotes the number of pairs of corresponding base-3 digits of m and n</span>
    <span class="c1"># that are equal to 2 and 1, respectively,</span>
    <span class="c1"># then the coefficient is congruent to 2**k, which reduces to 1 if k is even or 2 if k is odd.</span>

    <span class="c1"># We map our three colours/characters to our three codes.</span>
    <span class="n">colours</span> <span class="o">=</span> <span class="s1">&#39;RGB&#39;</span>
    <span class="n">code_for_colour</span> <span class="o">=</span> <span class="p">{</span><span class="n">colour</span><span class="p">:</span> <span class="n">code</span> <span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">colour</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">colours</span><span class="p">)}</span>

    <span class="c1"># We determine m and its base-3 digit sequence (starting with the least significant digit).</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">m_base_3_digits</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">m</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">m_base_3_digits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="c1"># For later use, we locate all 2s in the base-3 digit sequence of m.</span>
    <span class="n">positions_of_2s_in_m_base_3_digits</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">position</span> <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">digit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m_base_3_digits</span><span class="p">)</span> <span class="k">if</span> <span class="n">digit</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># We collect the first powers of 3, so that we can later quickly compute a number from its base-3 digit sequence.</span>
    <span class="c1"># (Note: The only difference between my solution for the &quot;Insane Coloured Triangles&quot; kata and this one occurs here.</span>
    <span class="c1"># Unlike the current kata, that one allowed use of Python 3.8, where itertools.accumulate&#39;s initial parameter first appeared.)</span>
    <span class="n">powers_of_3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_base_3_digits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">))</span>

    <span class="c1"># We will progressively compute the dot product of the vector of coefficients of the mth row of Pascal&#39;s triangle</span>
    <span class="c1"># with the vector of codes of colours in the given initial row, reducing modulo 3.</span>
    <span class="n">reduced_dot_product</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># We need only consider the nonzero coefficients in the mth row of Pascal&#39;s triangle,</span>
    <span class="c1"># so we visit all sequences of base-3 digits whose elements are no greater than the corresponding base-3 digits of m.</span>
    <span class="k">for</span> <span class="n">n_base_3_digits</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">m_base_3_digit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">m_base_3_digit</span> <span class="ow">in</span> <span class="n">m_base_3_digits</span><span class="p">)):</span>
        <span class="c1"># From the base-3 digit sequence we are now visiting, we compute the associated value of n.</span>
        <span class="c1"># (m choose n) is nonzero.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">n_base_3_digits</span><span class="p">,</span> <span class="n">powers_of_3</span><span class="p">))</span>
        <span class="c1"># We look up the code of the colour at the nth position in the given initial row.</span>
        <span class="n">nth_code_in_row</span> <span class="o">=</span> <span class="n">code_for_colour</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
        <span class="c1"># Only nonzero codes will result in nonzero contributions to our dot product.</span>
        <span class="k">if</span> <span class="n">nth_code_in_row</span><span class="p">:</span>
            <span class="c1"># We determine the value of (m choose n) reduced modulo 3,</span>
            <span class="c1"># multiply by the corresponding colour code in the given initial row,</span>
            <span class="c1"># and update our partial reduced dot product.</span>
            <span class="n">nth_coefficient</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n_base_3_digits</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions_of_2s_in_m_base_3_digits</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">reduced_dot_product</span> <span class="o">=</span> <span class="p">(</span><span class="n">reduced_dot_product</span> <span class="o">+</span> <span class="n">nth_coefficient</span> <span class="o">*</span> <span class="n">nth_code_in_row</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>

    <span class="c1"># If m is even, the dot product is congruent to the code of the colour at the bottom tip of the triangle,</span>
    <span class="c1"># while for odd m, the negated dot product is congruent to the desired code.</span>
    <span class="c1"># We thus determine the final code and return the associated colour character.</span>
    <span class="k">return</span> <span class="n">colours</span><span class="p">[(</span><span class="o">-</span><span class="n">reduced_dot_product</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">reduced_dot_product</span><span class="p">]</span>
</pre></div>

</div>

<h2>My Notes</h2>
To determine how reliably my code would meet the final compound test execution time requirement,
I attempted 10 runs, of which 4 completed within the limit.
I will try to continue to improve the efficiency of my implementation until it runs reliably within the permitted time.
</body>
</html>
